<!DOCTYPE html>
<html>
  <head>
    <title>ASCII Art Jump and Run</title>
    <style>
      body {
        font-family: monospace;
        white-space: pre;
        font-size: 16px;
      }
      #gameCanvas {
        line-height: 1;
      }
    </style>
  </head>
  <body>
    <div id="gameCanvas"></div>
    <script>
      const gameWorldWidth = 200; // Total width of the game world
      const gameWorldHeight = 20; // Height remains the same
      const canvasWidth = 80; // Width of the viewport (camera width)
      const canvasHeight = 20; // Viewport height
      const groundLevel = canvasHeight - 2;
      const defaultPlayerX = 10;
      let playerX = defaultPlayerX;
      let playerY = groundLevel;
      let isJumping = false;
      let jumpHeight = 2;
      let gravity = 0.5;
      let yVelocity = 0;
      const keysPressed = {};

      let cameraX = 0; // Camera starting position

      const platforms = [
        { x: 15, y: groundLevel - 4, width: 10 },
        { x: 50, y: groundLevel - 6, width: 15 },
        { x: 80, y: groundLevel - 8, width: 20 },
      ];

      // Enemies that throw projectiles
      const enemies = [
        {
          x: 40,
          y: groundLevel,
          throwingInterval: 60,
          projectileDirection: -1,
          projectileX: null,
          isCollided: false,
        },
        {
          x: 60,
          y: groundLevel,
          throwingInterval: 70,
          projectileDirection: -1,
          projectileX: null,
          isCollided: false,
        },
      ];

      // List of particles for effects
      const particles = [];

      // Particle effect class
      class Particle {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.xVelocity = (Math.random() - 0.5) * 2;
          this.yVelocity = Math.random() - 1;
          this.lifetime = 20;
        }

        update() {
          this.x += this.xVelocity;
          this.y += this.yVelocity;
          this.lifetime--;
        }

        render(cameraX, canvas) {
          if (
            this.lifetime > 0 &&
            this.x >= cameraX &&
            this.x < cameraX + canvasWidth &&
            this.y >= 0 &&
            this.y < canvasHeight
          ) {
            canvas[Math.floor(this.y)][Math.floor(this.x - cameraX)] = ".";
          }
        }
      }

      // Create the initial canvas
      const canvas = Array.from({ length: canvasHeight }, () =>
        Array(canvasWidth).fill(" ")
      );
      const gameCanvas = document.getElementById("gameCanvas");

      // Function to draw a tree
      function drawTree(x, y, cameraX) {
        const tree = ["  ^  ", " ^^^ ", "^^^^^", "  |  ", "  |  "];
        for (let i = 0; i < tree.length; i++) {
          for (let j = 0; j < tree[i].length; j++) {
            if (
              x + j >= cameraX &&
              x + j < cameraX + canvasWidth &&
              y + i < canvasHeight
            ) {
              canvas[y + i][x + j - cameraX] = tree[i][j];
            }
          }
        }
      }

      // Function to draw a cloud
      function drawCloud(x, y, cameraX) {
        const cloud = ["  ___  ", " (   ) ", "(     )", " (___) "];
        for (let i = 0; i < cloud.length; i++) {
          for (let j = 0; j < cloud[i].length; j++) {
            if (
              x + j >= cameraX &&
              x + j < cameraX + canvasWidth &&
              y + i < canvasHeight
            ) {
              canvas[y + i][x + j - cameraX] = cloud[i][j];
            }
          }
        }
      }

      // Function to draw platforms
      function drawPlatforms(cameraX) {
        for (const platform of platforms) {
          for (let x = platform.x; x < platform.x + platform.width; x++) {
            if (
              x >= cameraX &&
              x < cameraX + canvasWidth &&
              platform.y < canvasHeight
            ) {
              canvas[platform.y][x - cameraX] = "=";
            }
          }
        }
      }

      // Function to render the canvas
      function renderCanvas(cameraX) {
        // Fill background with empty spaces
        for (let y = 0; y < canvasHeight; y++) {
          for (let x = 0; x < canvasWidth; x++) {
            canvas[y][x] = " ";
          }
        }

        // Draw the ground
        for (let x = 0; x < canvasWidth; x++) {
          canvas[groundLevel + 1][x] = "=";
        }

        // Draw trees
        drawTree(5, groundLevel - 4, cameraX);
        drawTree(30, groundLevel - 4, cameraX);
        drawTree(55, groundLevel - 4, cameraX);
        drawTree(80, groundLevel - 4, cameraX);

        // Draw clouds
        drawCloud(20, 3, cameraX);
        drawCloud(50, 5, cameraX);
        drawCloud(80, 2, cameraX);

        // Draw platforms
        drawPlatforms(cameraX);

        // Draw enemies
        for (const enemy of enemies) {
          if (
            enemy.x >= cameraX &&
            enemy.x < cameraX + canvasWidth &&
            enemy.y < canvasHeight &&
            !enemy.isCollided
          ) {
            canvas[enemy.y][enemy.x - cameraX] = "E";
          }
        }

        // Draw projectiles
        for (const enemy of enemies) {
          if (enemy.projectileX !== null && !enemy.isCollided) {
            enemy.projectileX += enemy.projectileDirection;
            if (
              enemy.projectileX >= cameraX &&
              enemy.projectileX < cameraX + canvasWidth
            ) {
              canvas[enemy.y][enemy.projectileX - cameraX] = "-";
            } else {
              enemy.projectileX = null;
            }
          }
        }

        // Draw particles
        for (const particle of particles) {
          particle.render(cameraX, canvas);
        }

        // Draw the player
        canvas[playerY][playerX - cameraX] = "@";

        // Render the canvas to the DOM
        gameCanvas.textContent = canvas.map((row) => row.join("")).join("\n");
      }

      // Handle keyboard input
      document.addEventListener("keydown", (e) => {
        keysPressed[e.key] = true;
      });

      document.addEventListener("keyup", (e) => {
        keysPressed[e.key] = false;
        if (e.key === " ") {
          canJump = true;
        }
      });

      // Check if the player is touching a platform
      function onPlatform() {
        for (const platform of platforms) {
          if (
            playerX >= platform.x &&
            playerX < platform.x + platform.width &&
            playerY + 1 === platform.y
          ) {
            return true;
          }
        }
        return false;
      }

      // Check for collision with projectiles
      function checkProjectileCollision() {
        for (const enemy of enemies) {
          if (enemy.projectileX === playerX && enemy.y === playerY) {
            return true;
          }
        }
        return false;
      }

      // Check for collision with enemies
      function checkEnemyCollision() {
        for (const enemy of enemies) {
          if (playerY === enemy.y && playerX === enemy.x && !enemy.isCollided) {
            enemy.isCollided = true;
            createParticleEffect(enemy.x, enemy.y);
            return true;
          }
        }
        return false;
      }

      // Create particle effect
      function createParticleEffect(x, y) {
        for (let i = 0; i < 12; i++) {
          particles.push(new Particle(x, y));
        }
      }

      // Update camera position based on player position
      function updateCamera() {
        if (playerX - cameraX > canvasWidth / 2) {
          cameraX = playerX - canvasWidth / 2;
        } else if (playerX - cameraX < canvasWidth / 4) {
          cameraX = Math.max(0, playerX - canvasWidth / 4);
        }
        cameraX = Math.min(cameraX, gameWorldWidth - canvasWidth);
      }

      // Game loop
      function gameLoop() {
        if (keysPressed["ArrowRight"]) {
          playerX = Math.min(gameWorldWidth - 1, playerX + 1);
        } else if (keysPressed["ArrowLeft"]) {
          playerX = Math.max(0, playerX - 1);
        }

        if (keysPressed[" "] && !isJumping) {
          isJumping = true;
          yVelocity = -jumpHeight;
        }

        if (isJumping) {
          playerY += yVelocity;

          // Apply gravity
          yVelocity += gravity;

          // Check for landing on ground or platform
          if (playerY >= groundLevel) {
            playerY = groundLevel;
            isJumping = false;
          } else if (onPlatform()) {
            playerY =
              platforms.find(
                (platform) =>
                  playerX >= platform.x && playerX < platform.x + platform.width
              ).y - 1;
            isJumping = false;
          }
        } else if (playerY < groundLevel) {
          if (onPlatform()) {
            playerY =
              platforms.find(
                (platform) =>
                  playerX >= platform.x && playerX < platform.x + platform.width
              ).y - 1;
          } else {
            playerY = Math.min(groundLevel, playerY + gravity);
          }
        }

        // Handle enemy projectiles
        for (const enemy of enemies) {
          if (enemy.throwingInterval <= 0 && !enemy.isCollided) {
            enemy.projectileX = enemy.x + enemy.projectileDirection;
            enemy.throwingInterval = 60;
          } else {
            enemy.throwingInterval--;
          }
        }

        // Update particles and remove expired ones
        for (let i = particles.length - 1; i >= 0; i--) {
          if (particles[i].lifetime <= 0) {
            particles.splice(i, 1);
          } else {
            particles[i].update();
          }
        }

        // Check for projectile collision
        if (checkProjectileCollision()) {
          playerX = defaultPlayerX;
          playerY = groundLevel;
        }

        // Check for collision with enemies
        if (checkEnemyCollision()) {
          isJumping = false;
        }

        // Update the camera position
        updateCamera();

        // Render the canvas based on the camera position
        renderCanvas(cameraX);
      }

      setInterval(gameLoop, 1000 / 30);
    </script>
  </body>
</html>
